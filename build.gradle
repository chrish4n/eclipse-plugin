/*
 * Copyright 2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This buildfile is used to build a complete distribution archive of the gradle eclipse feature
 * The gradle eclipse feature contains two eclipse plugins:
 * 1. org.codehaus.gradle
 *	This plugin wraps a complete gradle distribution in a eclipse/osgi plugin and exports the gradle libs in its manifest to be
 *	reused by other osgi plugins
 *
 * 2. org.gradle.eclipse
 *	This plugin contains all logic, extension points and implementations to extend the eclipse ide. 
 *	By default it imports the gradle-api exported via org.codehaus.gradle
 *
 * To build this gradle eclipse plugin the following steps should be implemented in this build file:
 *	1. copy org.coehaus.gradle and org.gradle.eclipse to a build working directory.
	2. resolve a matching gradle distribution and merge it into the org.codehaus.gradle plugin skeleton.
	3. update the import/export statements in the osgi manifests of org.gradle.eclipse and org.codehaus.gradle
	4. resolve a eclipse distribution to run the pde build (actual we're using eclipse-sdk-3.5.2)
	4. run the pde build to
		- build a valid eclipse plugin archive
		- create a update site
		- run tests
 */

//util methods
String createBundleClasspath(FileTree zipContent){
	def BUNDLE_LIB_SEPERATOR = ",\n "
	
	StringBuffer buffer = new StringBuffer();
	zipContent.visit {node ->
		if(node.toString().endsWith("jar") && !node.toString().contains("/plugins/")){
			def filepath = node.relativePath.pathString
			def bundleClasspathEntry = filepath.substring(filepath.indexOf('/') + 1)
			buffer.append(bundleClasspathEntry).append(BUNDLE_LIB_SEPERATOR)
		}
	}
	def bundleClasspath = buffer.toString()
	
	//remove the last colone and linebreak
	bundleClasspath.substring(0, bundleClasspath.length() - BUNDLE_LIB_SEPERATOR.length())	
}
//

repositories {
  // get the latest available gradle snapshot. Are files resolved via URLResolver are cacheable?
  add(new org.apache.ivy.plugins.resolver.URLResolver()) {
    name = 'gradle-snapshots'
	addArtifactPattern 'http://snapshots.dist.codehaus.org/([organization]/)[artifact](-[revision])(-[classifier]).[ext]'
  }
}

configurations {
	workspaceSetup // the configuration to build a complete pde environment workspace including a valid gradle dist
	eclipseBase // the eclipse base setup needed to run a pde build
}

dependencies{
	workspaceSetup "gradle:gradle:0.9-20100315112026+0100:bin@zip"
}

//tasks
task clean(type: Delete) {
	from 'build'
}

task copyFragments(dependsOn:'clean') << {
    copy {
        from 'org.gradle.eclipse'
        into 'build/tmp/org.gradle.eclipse'
    }
    copy {
        from 'org.codehaus.gradle'
        into 'build/tmp/org.codehaus.gradle'
    }
	copy {
        from 'org.gradle.eclipse.feature'
        into 'build/tmp/org.gradle.eclipse.feature'
    }
}

task mergeGradleDist(dependsOn:'copyFragments') << {
	String BUNDLE_CLASSPATH_PLACEHOLDER = "_BUNDLE_CLASSPATH_"
	FileTree zipContent = null
	configurations.workspaceSetup.files.each { depFile ->
		zipContent =  zipTree(depFile)
		copy {
		    from(zipTree(depFile)) {
		        eachFile { details ->
		            details.path = details.path.substring(details.relativePath.segments[0].length())
		        }
		    }
		 	into 'build/tmp/org.codehaus.gradle/'
		}
	}	
	
	String bundleClasspath = createBundleClasspath(zipContent);
	File manifestFile = new File('build/tmp/org.codehaus.gradle/META-INF/MANIFEST.MF')
		
	def manifestContent = manifestFile.text
	manifestContent = manifestContent.replaceAll(BUNDLE_CLASSPATH_PLACEHOLDER, bundleClasspath)
	manifestFile.write(manifestContent)
}